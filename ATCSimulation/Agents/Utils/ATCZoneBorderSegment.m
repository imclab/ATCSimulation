//
//  ATCZoneBorder.m
//  ATCSimulation
//
//  Created by Ludovic Delaveau on 11/27/11.
//  Copyright (c) 2011 __MyCompanyName__. All rights reserved.
//

#import "ATCZoneBorderSegment.h"

@interface ATCZoneBorderSegment ()

@property (nonatomic, retain) ATCPoint *extremity1;
@property (nonatomic, retain) ATCPoint *extremity2;
@property (nonatomic, retain) NSNumber *aLine;
@property (nonatomic, retain) NSNumber *bLine;
@property (nonatomic, retain) NSNumber *cLine;
@property (nonatomic, assign) BOOL directionPositive;
@property (nonatomic, retain) NSNumber *aOrthogonalLine1;
@property (nonatomic, retain) NSNumber *bOrthogonalLine1;
@property (nonatomic, retain) NSNumber *cOrthogonalLine1;
@property (nonatomic, retain) NSNumber *aOrthogonalLine2;
@property (nonatomic, retain) NSNumber *bOrthogonalLine2;
@property (nonatomic, retain) NSNumber *cOrthogonalLine2;

- (BOOL)testHalfSpaceWithInequationCoefficientsA:(NSNumber *)a andB:(NSNumber *)b andC:(NSNumber *)c andInequalityPositive:(BOOL)positive atPoint:(ATCPoint *)testedPoint;

@end

@implementation ATCZoneBorderSegment

- (id)initWithExtremity1:(ATCPoint *)extremity1 andExtremity2:(ATCPoint *)extremity2 withDirectionPositive:(BOOL)positive {
    self = [super init];
    
    if (self) {
        self.directionPositive = positive;
        
        self.extremity1 = extremity1;
        self.extremity2 = extremity2;
        
        self.aLine = [NSNumber numberWithFloat:([self.extremity2.coordinateY floatValue] - [self.extremity1.coordinateY floatValue])];
        self.bLine = [NSNumber numberWithFloat:([self.extremity1.coordinateX floatValue] - [self.extremity2.coordinateX floatValue])];
        self.cLine = [NSNumber numberWithFloat:(- [self.bLine floatValue] * [self.extremity1.coordinateY floatValue] - [self.aLine floatValue] * [self.extremity1.coordinateX floatValue])];
        
        self.aOrthogonalLine1 = [NSNumber numberWithFloat:(- [self.bLine floatValue])];
        self.bOrthogonalLine1 = [NSNumber numberWithFloat:([self.aLine floatValue])];
        self.cOrthogonalLine1 = [NSNumber numberWithFloat:(- [self.bOrthogonalLine1 floatValue] * [self.extremity1.coordinateY floatValue] - [self.aOrthogonalLine1 floatValue] * [self.extremity1.coordinateX floatValue])];
        
        self.aOrthogonalLine2 = [NSNumber numberWithFloat:(- [self.bLine floatValue])];
        self.bOrthogonalLine2 = [NSNumber numberWithFloat:([self.aLine floatValue])];
        self.cOrthogonalLine2 = [NSNumber numberWithFloat:(- [self.bOrthogonalLine2 floatValue] * [self.extremity2.coordinateY floatValue] - [self.aOrthogonalLine2 floatValue] * [self.extremity2.coordinateX floatValue])];
    }
    
    return self;
}

@synthesize extremity1 = _extremity1;
@synthesize extremity2 = _extremity2;

@synthesize aLine = _aLine;
@synthesize bLine = _bLine;
@synthesize cLine = _cLine;
@synthesize directionPositive = _directionPositive;

@synthesize aOrthogonalLine1 = _aOrthogonalLine1;
@synthesize bOrthogonalLine1 = _bOrthogonalLine1;
@synthesize cOrthogonalLine1 = _cOrthogonalLine1;

@synthesize aOrthogonalLine2 = _aOrthogonalLine2;
@synthesize bOrthogonalLine2 = _bOrthogonalLine2;
@synthesize cOrthogonalLine2 = _cOrthogonalLine2;

- (BOOL)pointBelongsToGeneratedHalfSpace:(ATCPoint *)testedPoint {
    return [self testHalfSpaceWithInequationCoefficientsA:self.aLine andB:self.bLine andC:self.cLine andInequalityPositive:self.directionPositive atPoint:testedPoint];
}

- (NSNumber *)calculateDistanceToSegment:(ATCPosition *)testedPosition {
    NSNumber *distance = [NSNumber numberWithFloat:MAXFLOAT];
    
    // first verifies if the point is inside the space generated by the segment in the direction
    BOOL line = [self testHalfSpaceWithInequationCoefficientsA:self.aLine andB:self.bLine andC:self.cLine andInequalityPositive:!self.directionPositive atPoint:testedPosition.coordinates];
    
    if (line) {
        // ok the point belongs to our zone segment, let's calculate the distance
        float cosCourse = cosf(testedPosition.course * M_2_PI / 360.0);
        float sinCourse = sinf(testedPosition.course * M_2_PI / 360.0);
        
        float generatedLineYIntersect = sinCourse * [testedPosition.coordinates.coordinateY floatValue] + cosCourse * [testedPosition.coordinates.coordinateX floatValue];
        
        float intersectionY = (generatedLineYIntersect + cosCourse) / ([self.aLine floatValue] * sinCourse - [self.bLine floatValue] * cosCourse);
        float intersectionX = - (sinCourse * intersectionY - generatedLineYIntersect) / cosCourse;
        
        if (intersectionX >= [self.extremity1.coordinateX floatValue] && intersectionX <= [self.extremity2.coordinateX floatValue] && intersectionY >= [self.extremity1.coordinateY floatValue] && intersectionY <= [self.extremity2.coordinateY floatValue]) {
            // intersection is inside the segment, ok
            return [NSNumber numberWithFloat:sqrtf(powf([testedPosition.coordinates.coordinateX floatValue] - intersectionX, 2) + powf([testedPosition.coordinates.coordinateY floatValue] - intersectionY, 2))];
        }
        
        return [distance autorelease];
    }
    
    return [distance autorelease];
}

- (BOOL)testHalfSpaceWithInequationCoefficientsA:(NSNumber *)a andB:(NSNumber *)b andC:(NSNumber *)c andInequalityPositive:(BOOL)positive atPoint:(ATCPoint *)testedPoint {
    NSNumber *inequationResult = [NSNumber numberWithFloat:([a floatValue] * [testedPoint.coordinateX floatValue] + [b floatValue] * [testedPoint.coordinateY floatValue] + [c floatValue])];
    
    if (positive) {
        return inequationResult >= 0;
    } else {
        return inequationResult <= 0;
    }
}

- (void)dealloc {
    self.extremity1 = nil;
    self.extremity2 = nil;
    
    self.aLine = nil;
    self.bLine = nil;
    self.cLine = nil;
    
    self.aOrthogonalLine1 = nil;
    self.bOrthogonalLine1 = nil;
    self.cOrthogonalLine1 = nil;
    
    self.aOrthogonalLine2 = nil;
    self.bOrthogonalLine2 = nil;
    self.cOrthogonalLine2 = nil;
    
    [super dealloc];
}

@end
