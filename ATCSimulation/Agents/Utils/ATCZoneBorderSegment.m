//
//  ATCZoneBorder.m
//  ATCSimulation
//
//  Created by Ludovic Delaveau on 11/27/11.
//  Copyright (c) 2011 __MyCompanyName__. All rights reserved.
//

#import "ATCZoneBorderSegment.h"

@interface ATCZoneBorderSegment ()

@property (nonatomic, retain) ATCPoint *extremity1;
@property (nonatomic, retain) ATCPoint *extremity2;
@property (nonatomic, assign) float aLine;
@property (nonatomic, assign) float bLine;
@property (nonatomic, assign) float cLine;
@property (nonatomic, assign) BOOL directionPositive;
@property (nonatomic, assign) float aOrthogonalLine1;
@property (nonatomic, assign) float bOrthogonalLine1;
@property (nonatomic, assign) float cOrthogonalLine1;
@property (nonatomic, assign) float aOrthogonalLine2;
@property (nonatomic, assign) float bOrthogonalLine2;
@property (nonatomic, assign) float cOrthogonalLine2;

- (BOOL)testPoint:(ATCPoint *)testedPoint IsInHalfSpaceOfLineWithCoefficientsA:(float )a B:(float )b C:(float )c andInequalityPositive:(BOOL)positive;

@end

@implementation ATCZoneBorderSegment

- (id)initWithExtremity1:(ATCPoint *)extremity1 andExtremity2:(ATCPoint *)extremity2 withDirectionPositive:(BOOL)positive {
    self = [super init];
    
    if (self) {
        self.directionPositive = positive;
        
        self.extremity1 = extremity1;
        self.extremity2 = extremity2;
        
        self.aLine = self.extremity2.Y - self.extremity1.Y;
        self.bLine = self.extremity1.X - self.extremity2.X;
        self.cLine = - self.bLine * self.extremity1.Y - self.aLine * self.extremity1.X;
        
        self.aOrthogonalLine1 = self.bLine;
        self.bOrthogonalLine1 = - self.aLine;
        self.cOrthogonalLine1 = - self.bOrthogonalLine1 * self.extremity1.Y - self.aOrthogonalLine1 * self.extremity1.X;
        
        self.aOrthogonalLine2 = self.bLine;
        self.bOrthogonalLine2 = - self.aLine;
        self.cOrthogonalLine2 = - self.bOrthogonalLine2 * self.extremity2.Y - self.aOrthogonalLine2 * self.extremity2.X;
    }
    
    return self;
}

@synthesize extremity1 = _extremity1;
@synthesize extremity2 = _extremity2;

@synthesize aLine = _aLine;
@synthesize bLine = _bLine;
@synthesize cLine = _cLine;
@synthesize directionPositive = _directionPositive;

@synthesize aOrthogonalLine1 = _aOrthogonalLine1;
@synthesize bOrthogonalLine1 = _bOrthogonalLine1;
@synthesize cOrthogonalLine1 = _cOrthogonalLine1;

@synthesize aOrthogonalLine2 = _aOrthogonalLine2;
@synthesize bOrthogonalLine2 = _bOrthogonalLine2;
@synthesize cOrthogonalLine2 = _cOrthogonalLine2;

# pragma mark - Segment and point methods

- (float)calculateDistanceToSegment:(ATCAirplaneInformation *)testedPosition {
    float distance = MAXFLOAT;
    
    // first verifies if the point is inside the space generated by the segment in the direction
    BOOL line = [self testPoint:testedPosition.coordinates IsInHalfSpaceOfLineWithCoefficientsA:self.aLine B:self.bLine C:self.cLine andInequalityPositive:self.directionPositive];
    
    if (line) {
        // ok the point belongs to our zone segment, let's calculate the distance
        float cosCourse = cosf(testedPosition.course * 2 * M_PI / 360.0);
        float sinCourse = sinf(testedPosition.course * 2 * M_PI / 360.0);
        
        float generatedLineYIntersect = sinCourse * testedPosition.coordinates.Y + cosCourse * testedPosition.coordinates.X;
        
        float intersectionY = (generatedLineYIntersect + cosCourse) / (self.aLine * sinCourse - self.bLine * cosCourse);
        float intersectionX = - (sinCourse * intersectionY - generatedLineYIntersect) / cosCourse;
        
        if (intersectionX >= self.extremity1.X && intersectionX <= self.extremity2.X && intersectionY >= self.extremity1.Y  && intersectionY <= self.extremity2.Y) {
            // intersection is inside the segment, ok
            return sqrtf(powf(testedPosition.coordinates.X - intersectionX, 2) + powf(testedPosition.coordinates.Y - intersectionY, 2));
        }
    }
    
    return distance;
}

# pragma mark Point inside segment half-space related methods

- (BOOL)pointBelongsToGeneratedHalfSpace:(ATCPoint *)testedPoint {
    BOOL insideSegment = [self checkIfProjectionIsInsideSegmentWithPoint:testedPoint];
    if (insideSegment) {
        // tests if on the right side
        return [self testPoint:testedPoint IsInHalfSpaceOfLineWithCoefficientsA:self.aLine B:self.bLine C:self.cLine andInequalityPositive:self.directionPositive];
    }
    return NO;
}

- (BOOL)testPoint:(ATCPoint *)testedPoint IsInHalfSpaceOfLineWithCoefficientsA:(float )a B:(float )b C:(float )c andInequalityPositive:(BOOL)positive {
    float inequationResult = a * testedPoint.X + b * testedPoint.Y + c;
    
    if (positive) {
        if (b > 0) {
            return inequationResult >= 0;
        } else if (b < 0) {
            return inequationResult <= 0;
        } else {
            if (a > 0) {
                return inequationResult >= 0;
            } else {
                return inequationResult <= 0;
            }
        }
    } else {
        if (b > 0) {
            return inequationResult <= 0;
        } else if (b < 0) {
            return inequationResult >= 0;
        } else {
            if (a > 0) {
                return inequationResult <= 0;
            } else {
                return inequationResult >= 0;
            }
        }

        
    }
}

- (BOOL)checkIfProjectionIsInsideSegmentWithPoint:(ATCPoint *)testedPoint {
    ATCPoint *intersectionPoint = [self calculateLinesIntersectionWithPoint:testedPoint];
    float deltaSegmentX = self.extremity2.X - self.extremity1.X;
    float deltaX = self.extremity2.X - intersectionPoint.X;
    
    if (!(deltaSegmentX >= 0 && deltaX >= 0) && !(deltaSegmentX <= 0 && deltaX <= 0)) {
        // if the two vectors are not in the same direction
        return FALSE;
    }
    
    float deltaSegmentY = self.extremity2.Y - self.extremity1.Y;
    float deltaY = self.extremity2.Y - intersectionPoint.Y;

    if (!(deltaSegmentY >= 0 && deltaY >= 0) && !(deltaSegmentY <= 0 && deltaY <= 0)) {
        // if the two vectors are not in the same direction
        return FALSE;
    }
    
    deltaSegmentX = deltaSegmentX > 0 ? deltaSegmentX : - deltaSegmentX;
    deltaX = deltaX >= 0 ? deltaX : - deltaX;
    
    deltaSegmentY = deltaSegmentY > 0 ? deltaSegmentY : - deltaSegmentY;
    deltaY = deltaY >= 0 ? deltaY : - deltaY;
    
    return deltaX <= deltaSegmentX && deltaY <= deltaSegmentY;
}

- (ATCPoint *)calculateLinesIntersectionWithPoint:(ATCPoint *)testedPoint {
    // finishes the calculation of the line orthogonal to the segment and going through testedPoint
    float cOrthogonalLine = - self.bOrthogonalLine1 * testedPoint.Y - self.aOrthogonalLine1 * testedPoint.X;
    
    float x, y;
    
    // calculates the point of intersection between the line and the segment
    if (self.aLine == 0) {
        x = - cOrthogonalLine / self.bLine;
        y = - self.cLine / self.bLine;
    } else if (self.bLine == 0) {
        x = - self.cLine / self.aLine;
        y = cOrthogonalLine / self.aLine;
    } else {
        x = (- self.aLine * self.cLine - self.bLine * cOrthogonalLine) / ((self.aLine * self.aLine + self.bLine * self.bLine));
        y = (self.aLine * (self.aLine * self.cLine + self.bLine * cOrthogonalLine) - self.cLine * (self.bLine * self.bLine + self.aLine * self.aLine)) / ((self.bLine * self.bLine + self.aLine * self.aLine) * self.bLine);
    }
    
    return [[[ATCPoint alloc] initWithCoordinateX:x andCoordinateY:y] autorelease];
}

- (void)dealloc {
    self.extremity1 = nil;
    self.extremity2 = nil;
    
    [super dealloc];
}

@end
